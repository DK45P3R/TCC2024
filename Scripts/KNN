import pandas as pd
from sklearn.model_selection import train_test_split, cross_val_score, GridSearchCV
from sklearn.preprocessing import StandardScaler
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import classification_report, confusion_matrix, roc_curve, auc
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import pickle

# Função para treinar e avaliar o modelo KNN para um conjunto de dados específico
def train_and_evaluate_knn(data_benign_path, data_malign_path, model_name):
    # Carregar os arquivos CSV
    data_benign = pd.read_csv(data_benign_path, encoding='ISO-8859-1', sep=';', on_bad_lines='skip')
    data_malign = pd.read_csv(data_malign_path, encoding='ISO-8859-1', sep=';', on_bad_lines='skip')

    # Adicionar coluna de rótulo
    data_malign['label'] = 1
    data_benign['label'] = 0

    # Remover a coluna "Nome do Arquivo" de cada dataset
    data_benign = data_benign.drop(columns=['Nome do Arquivo'])
    data_malign = data_malign.drop(columns=['Nome do Arquivo'])

    # Concatenar os dados
    data = pd.concat([data_benign, data_malign], ignore_index=True)

    # Preencher valores faltantes com 0
    data = data.fillna(0)

    # Remover colunas não numéricas (como hashes, nomes de arquivos, etc.)
    data = data.apply(pd.to_numeric, errors='coerce').fillna(0)

    # Separar características e rótulos
    X = data.drop('label', axis=1)
    y = data['label']

    # Dividir os dados em conjuntos de treinamento e teste
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=0)

    # Padronizar os dados com StandardScaler
    scaler = StandardScaler()
    X_train = scaler.fit_transform(X_train)
    X_test = scaler.transform(X_test)

    # Definir o intervalo de valores para n_neighbors
    param_grid = {'n_neighbors': [1, 3, 5, 7, 9, 11, 15, 20, 50, 75, 100]}

    # Realizar busca em grid para encontrar o melhor n_neighbors
    grid_search = GridSearchCV(KNeighborsClassifier(weights='distance'), param_grid, cv=5, scoring='accuracy')
    grid_search.fit(X_train, y_train)

    # Melhor valor de n_neighbors encontrado
    best_n_neighbors = grid_search.best_params_['n_neighbors']
    print(f"\nMelhor valor de n_neighbors para {model_name}: {best_n_neighbors}")

    # Usar o melhor modelo encontrado no GridSearch
    knn_best = grid_search.best_estimator_

    # Fazer previsões com o melhor modelo
    y_pred = knn_best.predict(X_test)
    y_pred_prob = knn_best.predict_proba(X_test)[:, 1]

    # Gerar o relatório de classificação
    report = classification_report(y_test, y_pred, target_names=['benigno', 'maligno'])
    print(f"\nRelatório de Classificação para {model_name}:\n", report)

    # Exibir a matriz de confusão
    conf_matrix = confusion_matrix(y_test, y_pred)
    print(f"Matriz de Confusão para {model_name}:\n", conf_matrix)

    # Gráfico de Acurácia (Validação Cruzada)
    cv_scores = cross_val_score(knn_best, X, y, cv=5)
    print(f"\nValidação Cruzada (5-fold) - Acurácia Média para {model_name}:", cv_scores.mean())

    # Adicionar curva de acurácia ao gráfico de acurácia
    plt.figure(1)
    plt.plot(range(1, 6), cv_scores, marker='o', label=f"Acurácia ({model_name})")

    # Gráfico ROC
    fpr, tpr, _ = roc_curve(y_test, y_pred_prob)
    roc_auc = auc(fpr, tpr)

    plt.figure(2)
    plt.plot(fpr, tpr, lw=2, label=f"{model_name} (área = {roc_auc:.2f})")

    # Gráfico de Matriz de Confusão
    plt.figure(figsize=(5, 4))
    sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='Blues', cbar=False, xticklabels=['Benigno', 'Maligno'], yticklabels=['Benigno', 'Maligno'])
    plt.xlabel("Classe Predita")
    plt.ylabel("Classe Verdadeira")
    plt.title(f"Matriz de Confusão para {model_name}")
    plt.show()

    # Salvando o modelo treinado
    arquivo_pickle = f"KNN_{model_name}_best.sav"
    pickle.dump(knn_best, open(arquivo_pickle, 'wb'))

# Chamando a função para os três conjuntos de dados
train_and_evaluate_knn('api_calls_2b.csv', 'api_calls_2m.csv', 'API_Calls')
train_and_evaluate_knn('opcodes_2b.csv', 'opcodes_2m.csv', 'Opcodes')
train_and_evaluate_knn('permissions_2b.csv', 'permissions_2m.csv', 'Permissions')

# Ajustando e exibindo o gráfico de acurácia
plt.figure(1)
plt.title("Acurácia da Validação Cruzada (5-fold)")
plt.xlabel("Fold")
plt.ylabel("Acurácia")
plt.grid()
plt.legend()
plt.show()

# Ajustando e exibindo o gráfico de ROC
plt.figure(2)
plt.plot([0, 1], [0, 1], color='grey', linestyle='--')
plt.xlabel("Taxa de Falso Positivo")
plt.ylabel("Taxa de Verdadeiro Positivo")
plt.title("Curva ROC")
plt.legend(loc="lower right")
plt.show()
